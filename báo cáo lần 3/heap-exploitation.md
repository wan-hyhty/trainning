# Heap là gì?

- Bộ nhớ heap là một vùng bộ nhớ được sử dụng để cấp phát động trong chương trình máy tính. Điều này có nghĩa là nó có thể cấp phát một lượng bộ nhớ không biết trước được tại thời điểm biên dịch. Heap thường được sử dụng để cấp phát bộ nhớ cho các đối tượng động được tạo ra trong khi chương trình đang chạy, chẳng hạn như các biến, mảng và cấu trúc dữ liệu.

## Libc là gì?

- Libc sẽ chứa các hàm tiêu chuẩn như malloc, calloc vân vân. Mỗi phiên bản libc offset của các hàm cũng khác nhau. Trong khai thác các challenge về heap, ta cần có được phiên bản đúng trên server (nếu cần). Ta cũng có thể sử dụng một cái gì đó như LD_PRELOAD
  > (LD_PRELOAD là một biến môi trường trong hệ thống Linux. Nó được sử dụng để chỉ định các thư viện được tải trước khi các thư viện khác trong hệ thống.)

## Malloc chunk

- Khi sử dụng hàm malloc, malloc sẽ tạo ra một khối bộ nhớ được gọi là chunk. Mỗi chunk sẽ khác nhau tuỳ vào kích thước khai báo. Chunk gồm `header chunk` để chứa các thông tin về chunk (kích thước, trạng thái - đã được cấp phát hay chưa)
- Trên `x64` header chunk có 0x10 byte và `x86` có 0x8 byte
- Ví dụ, ta có chương trình sau, tạo một vùng nhớ heap, sau đó đưa chuỗi `"panda"` vào trong vùng nhớ heap ấy

```c
void main(void)
{
    char *ptr;

    ptr = malloc(0x10);

    strcpy(ptr, "panda");
}

```

- Khi ta kiểm tra

```
gef➤  search-pattern panda
[+] Searching 'panda' in memory
[+] In '[heap]'(0x555555559000-0x55555557a000), permission=rw-
  0x555555559260 - 0x555555559265  →   "panda"
gef➤  x/4g 0x555555559250
0x555555559250:    0x0    0x21
0x555555559260:    0x61646e6170    0x0
```

- Giống như lí thuyết, phần header sẽ được đặt ở đầu chunk chứa các thông tin sau

```
0x0:    0x00     - Previous Chunk Size
0x8:    0x21     - Chunk Size
0x10:     "panda"     - Content of chunk
```

```
0x0:    0x00     - Previous Chunk Size
```

- Kích thước chunk trước đó chỉ định kích thước một chunk trước đó đã được khai báo
- Ở đây, ta sẽ hiểu kích thước của chunk trước đó như sau
  - Nếu chunk 1 và chunk 2 nằm sau chunk 1 (không nhất thiết là liền kề) thì header chunk thứ 2 không chứa size của chunk thứ 1, nhưng nếu chunk thứ 1 được giải phóng, thì chunk thứ 2 sẽ cập nhật phần header chunk 2 là size của chunk 1(hoặc có thể hiểu là vùng địa chỉ trống trước nó)
  - Nếu ta tạo chunk 3, có size nhỏ hơn vùng nhớ trống trước chunk 2 thì chunk 3 sẽ được đặt trước chunk 2

```
0x8:    0x21     - Chunk Size
```

- Ở đây ta tạo khai báo chunk là 0x10 byte nhưng header nhận 0x21 byte là do 0x10 byte của phần header chunk `x64` và 0x10 là dữ liệu. Nghĩa là `size_khai_báo` + `header_size` = `chunk_size` (làm tròn)
- Ví dụ nếu khai báo 0x15 thì ta sẽ có 0x15 + 0x10 = 0x25 và được làm tròn là 0x30
- Mục đích làm tròn để dễ dàng quản lí hơn
- Ngoài ra, số 0x1 trong cả 0x91 và 0x21 đến từ bit trước đó đang được sử dụng, chỉ ra rằng chunk trước đó đang được sử dụng và không được giải phóng.
- Nếu chunk trước đó không được giải phóng và bạn tạo một chunk mới, kích thước của chunk mới sẽ được tăng thêm 0x1 byte để lưu trữ bit "in-use" của chunk trước đó. Bit "in-use" này chỉ ra rằng chunk trước đó đang được sử dụng và không được giải phóng.

### Ba bit đầu tiên

- Ba bit đầu tiên của kích thước được cấp phát bởi malloc là các cờ (flags) và chúng chỉ ra các thông tin khác nhau (là một phần của lý do để làm tròn kích thước). Nếu bit được thiết lập, điều đó có nghĩa là cờ tương ứng là đúng (và ngược lại)

```
0x1:     Previous in Use     - Specifies that the chunk before it in memory is in use
0x2:    Is MMAPPED               - Specifies that the chunk was obtained with mmap()
0x4:     Non Main Arena         - Specifies that the chunk was obtained from outside of the main arena
```

- Bit đầu tiên (bit cao nhất) được sử dụng để chỉ định kích thước của chunk. Nếu bit này được thiết lập, chunk có kích thước lớn hơn hoặc bằng 512 byte. Nếu bit này không được thiết lập, chunk có kích thước nhỏ hơn 512 byte.
- Bit thứ hai được sử dụng để chỉ định xem chunk có phải là một chunk được cấp phát gần đây hay không. Nếu bit này được thiết lập, chunk được cấp phát gần đây. Nếu bit này được thiết lập, chunk được cấp phát trước đó và đã được giải phóng
- Bit thứ ba được sử dụng để chỉ định xem chunk có phải là một chunk được cấp phát để lưu trữ một con trỏ hay không. Nếu bit này được thiết lập, chunk được cấp phát để lưu trữ một con trỏ. Nếu bit này không được thiết lập, chunk được cấp phát để lưu trữ dữ liệu. Ví dụ: Nếu kích thước được cấp phát là 0x100, bit thứ ba không được thiết lập, do đó chunk này được cấp phát để lưu trữ dữ liệu.

## Binning

- Tạm hiểu là danh sách các vùng nhớ trống, khi một vùng nhớ được giải phóng, nó sẽ lưu vùng nhớ vào bin, và khi khai báo một chunk mới, nó sẽ kiểm tra trong bin vùng nhớ nào phù hợp với chunk đấy

### Fast bin

- Gồm 7 danh sách liên kết, được đánh số và có kích thước tương ứng

```
────────────────────── Fastbins for arena 0x7ffff7dd1b20 ──────────────────────
Fastbins[idx=0, size=0x10]  ←  Chunk(addr=0x602010, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x602030, size=0x20, flags=PREV_INUSE)
Fastbins[idx=1, size=0x20]  ←  Chunk(addr=0x602050, size=0x30, flags=PREV_INUSE)
Fastbins[idx=2, size=0x30]  ←  Chunk(addr=0x602080, size=0x40, flags=PREV_INUSE)
Fastbins[idx=3, size=0x40]  ←  Chunk(addr=0x6020c0, size=0x50, flags=PREV_INUSE)
Fastbins[idx=4, size=0x50]  ←  Chunk(addr=0x602110, size=0x60, flags=PREV_INUSE)
Fastbins[idx=5, size=0x60]  ←  Chunk(addr=0x602170, size=0x70, flags=PREV_INUSE)
Fastbins[idx=6, size=0x70]  ←  Chunk(addr=0x6021e0, size=0x80, flags=PREV_INUSE)
```

- Ví dụ, chunk 1 có size là 0x30, nó sẽ được đưa vào fast bin và gán index là 2
- Fast bin được tổ chức theo cơ chế LIFO tương tự như stack.
- Ví dụ chunk 0x80 được đưa vào, rồi đến chunk 0x20 thì chunk 0x20 phải được đưa ra trước thì mới có thể đưa chunk 0x80 ra

### tcache

- Thùng tcache tương tự như thùng nhanh (Fast Bins), nhưng có những khác biệt, hoạt động như stack.
- Thùng tcache là một cơ chế phân chia mới được giới thiệu trong phiên bản libc 2.26 (trước đó, bạn sẽ không thấy thùng tcache). Thùng tcache là đặc thù của từng luồng (thread), vì vậy mỗi luồng đều có một thùng tcache riêng của nó.
- Trong các phiên bản libc có thùng tcache, thùng tcache là nơi đầu tiên mà malloc sẽ tìm để phân bổ khối hoặc để đặt các khối được giải phóng vào (vì nó nhanh hơn).
- Khi một khối được giải phóng trong một luồng, nó sẽ được chèn vào thùng tcache của luồng đó thay vì chèn vào fast bin chung. Khi một luồng cần phân bổ một khối mới, nó sẽ tìm kiếm trước trong thùng tcache của chính nó để kiểm tra xem có khối nào đủ kích thước để sử dụng hay không. Việc tìm kiếm này nhanh hơn so với việc tìm kiếm trong thùng fast bin vì không cần phải đồng bộ hóa giữa các luồng.

### Unsorted, Large and Small Bins

- Các bin Small, Large và Unsorted được liên kết chặt chẽ hơn với nhau trong cách thức hoạt động của chúng hơn các bin khác. Các bin Unsorted, Large và Small đều được lưu trữ trong cùng một mảng. Mỗi bin có các chỉ mục khác nhau trỏ đến mảng này:

```
0x00:         Not Used
0x01:         Unsorted Bin
0x02 - 0x3f:  Small Bin
0x40 - 0x7e:  Large Bin
```

- Có một danh sách cho Unsorted Bin, 62 danh sách cho Small Bin và 63 danh sách cho Large Bin.
- Các khối bộ nhớ trong Unsorted Bin không được sắp xếp theo kích thước, mà được lưu trữ trong một danh sách liên kết đơn. Hệ thống sẽ kiểm tra Unsorted Bin trước tiên để tìm kiếm bất kỳ khối bộ nhớ nào có thể
- Khi hệ thống kiểm tra Unsorted Bin, nó cũng sẽ kiểm tra xem có khối bộ nhớ nào có thể thuộc về các danh sách khác như Small Bin hoặc Large Bin hay không.
- Tương tự như fast bin, 62 danh sách của Small Bin và 63 danh sách của Large Bin được chia thành nhiều phần theo kích thước. Các Small Bin trên x64 bao gồm các kích thước khối nhỏ hơn 0x400 (1024 byte), và trên x86 bao gồm các kích thước khối nhỏ hơn 0x200 (512 byte), trong khi large bin bao gồm các khối bộ nhớ có kích thước lớn hơn các giá trị trên đó.

#### So sánh

|                | Unsorted bin                                                                                                                                                                                                                                       | Large bin                                                                                                                                                                                                                       | Small bin                                                                                                                                                                                                                      |
| -------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Ưu điểm**    | Thời gian giải phóng khối bộ nhớ nhanh hơn so với các bin khác do không cần sắp xếp lại khối bộ nhớ theo kích thước. Thích hợp cho các khối bộ nhớ có kích thước ngẫu nhiên.                                                                       | Thời gian phân bổ bộ nhớ nhanh hơn so với small bin do chỉ cần tìm kiếm trong danh sách large bin. Giảm thiểu fragmentation bộ nhớ bằng cách giữ các khối bộ nhớ lớn hơn một giá trị ngưỡng nhất định trong cùng một danh sách. | Thời gian phân bổ bộ nhớ nhanh hơn so với large bin do chỉ cần tìm kiếm trong danh sách small bin.Giảm thiểu fragmentation bộ nhớ bằng cách giữ các khối bộ nhớ nhỏ hơn giá trị ngưỡng của large bin trong cùng một danh sách. |
| **Nhược điểm** | Thời gian phân bổ bộ nhớ chậm hơn so với các bin khác do phải tìm kiếm trong danh sách unsorted bin trước. Có thể dẫn đến fragmentation bộ nhớ nếu các khối bộ nhớ được giải phóng và phân bổ liên tục không có giải phóng khối bộ nhớ giữa chúng. | Thời gian giải phóng khối bộ nhớ chậm hơn so với small bin do phải duyệt danh sách liên kết đôi. Có thể dẫn đến wasting space nếu các khối bộ nhớ lớn không được sử dụng hết.                                                   | Thời gian giải phóng khối bộ nhớ chậm hơn so với large bin do phải duyệt danh sách liên kết đơn. Có thể dẫn đến wasting space nếu các khối bộ nhớ nhỏ không được sử dụng hết.                                                  |

## Consolidation

- Chức năng của consolidation là gộp các vùng nhớ trống liền kề với nhau tạo thành một chunk trống lớn hơn
  ví dụ

```
tại các địa chỉ sau có, nếu không sử dụng consolidation
0x1000 (allocated)
0x2000 (free)
0x3000 (free)
0x4000 (allocated)
0x5000 (free)
0x6000 (allocated)
0x7000 (allocated)
```

- Nếu ta khai báo một chunk có kích thước là 0x2000 thì không có chunk trống nào phù hợp (vì nó chưa hiểu có 2 chunk 0x1000 byte đang liền kề nhau)
- Nếu ta sử dụng consolidation

```
0x1000 (allocated)
0x2000 (free + consolidated)
0x3000 (free)
0x4000 (allocated)
0x5000 (free)
0x6000 (allocated)
0x7000 (allocated)
```

- Khi được sử dụng consolidated, hệ thống sẽ hiểu là ta muốn gộp 2 vùng nhớ 0x2000 và 0x3000 thành 1 vùng nhớ trống có kích thước là 0x2000 (không còn là 0x1000 và 0x1000)

## Top chunk
- Top Chunk là một khối bộ nhớ lớn cuối cùng trong heap, được sử dụng để giữ các khối bộ nhớ chưa được phân bổ. Top Chunk cũng là nơi các yêu cầu phân bổ bộ nhớ mới sẽ được xử lý bởi hàm malloc.
- Lấy ví dụ để dễ hiểu
- Ta có một vùng địa chỉ sau:
```
0x1000 (allocated)
0x2000 (free)
0x3000 (allocated)
0x4000 (free)
0x5000 (free)
0x6000 (top chunk)
```
- giả sử khai báo một chunk có kích thước 0x2000 thì chương trình sẽ trả lại cho ta như sau
```
0x1000 (allocated)
0x2000 (allocated, được trả về cho bạn)
0x3000 (allocated)
0x4000 (free)
0x5000 (free)
0x6000 (top chunk)
```