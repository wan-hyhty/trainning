# Heap là gì?

- Bộ nhớ heap là một vùng bộ nhớ được sử dụng để cấp phát động trong chương trình máy tính. Điều này có nghĩa là nó có thể cấp phát một lượng bộ nhớ không biết trước được tại thời điểm biên dịch. Heap thường được sử dụng để cấp phát bộ nhớ cho các đối tượng động được tạo ra trong khi chương trình đang chạy, chẳng hạn như các biến, mảng và cấu trúc dữ liệu.

## Libc là gì?

- Libc sẽ chứa các hàm tiêu chuẩn như malloc, calloc vân vân. Mỗi phiên bản libc offset của các hàm cũng khác nhau. Trong khai thác các challenge về heap, ta cần có được phiên bản đúng trên server (nếu cần). Ta cũng có thể sử dụng một cái gì đó như LD_PRELOAD
  > (LD_PRELOAD là một biến môi trường trong hệ thống Linux. Nó được sử dụng để chỉ định các thư viện được tải trước khi các thư viện khác trong hệ thống.)

## Malloc chunk

- Khi sử dụng hàm malloc, malloc sẽ tạo ra một khối bộ nhớ được gọi là chunk. Mỗi chunk sẽ khác nhau tuỳ vào kích thước khai báo. Chunk gồm `header chunk` để chứa các thông tin về chunk (kích thước, trạng thái - đã được cấp phát hay chưa)
- Trên `x64` header chunk có 0x10 byte và `x86` có 0x8 byte
- Ví dụ, ta có chương trình sau, tạo một vùng nhớ heap, sau đó đưa chuỗi `"panda"` vào trong vùng nhớ heap ấy

```c
void main(void)
{
    char *ptr;

    ptr = malloc(0x10);

    strcpy(ptr, "panda");
}

```

- Khi ta kiểm tra

```
gef➤  search-pattern panda
[+] Searching 'panda' in memory
[+] In '[heap]'(0x555555559000-0x55555557a000), permission=rw-
  0x555555559260 - 0x555555559265  →   "panda"
gef➤  x/4g 0x555555559250
0x555555559250:    0x0    0x21
0x555555559260:    0x61646e6170    0x0
```

- Giống như lí thuyết, phần header sẽ được đặt ở đầu chunk chứa các thông tin sau

```
0x0:    0x00     - Previous Chunk Size
0x8:    0x21     - Chunk Size
0x10:     "pada"     - Content of chunk
```

```
0x0:    0x00     - Previous Chunk Size
```

- Kích thước chunk trước đó chỉ định kích thước một chunk trước đó đã được khai báo
- Ở đây, ta sẽ hiểu kích thước của chunk trước đó như sau
  - Nếu chunk 1 và chunk 2 nằm sau chunk 1 (không nhất thiết là liền kề) thì header chunk thứ 2 không chứa size của chunk thứ 1, nhưng nếu chunk thứ 1 được giải phóng, thì chunk thứ 2 sẽ cập nhật phần header chunk 2 là size của chunk 1(hoặc có thể hiểu là vùng địa chỉ trống trước nó)
  - Nếu ta tạo chunk 3, có size nhỏ hơn vùng nhớ trống trước chunk 2 thì chunk 3 sẽ được đặt trước chunk 2

```
0x8:    0x21     - Chunk Size
```

- Ở đây ta tạo khai báo chunk là 0x10 byte nhưng header nhận 0x21 byte là do 0x10 byte của phần header chunk `x64` và 0x10 là dữ liệu. Nghĩa là `size_khai_báo` + `header_size` = `chunk_size` (làm tròn)
- Ví dụ nếu khai báo 0x15 thì ta sẽ có 0x15 + 0x10 = 0x25 và được làm tròn là 0x30
- Mục đích làm tròn để dễ dàng quản lí hơn
- Ngoài ra, số 0x1 trong cả 0x91 và 0x21 đến từ bit trước đó đang được sử dụng, chỉ ra rằng chunk trước đó đang được sử dụng và không được giải phóng.
- Nếu chunk trước đó không được giải phóng và bạn tạo một chunk mới, kích thước của chunk mới sẽ được tăng thêm 0x1 byte để lưu trữ bit "in-use" của chunk trước đó. Bit "in-use" này chỉ ra rằng chunk trước đó đang được sử dụng và không được giải phóng.
